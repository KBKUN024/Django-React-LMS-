"""
Django settings for backend project.

Generated by 'django-admin startproject' using Django 5.2.5.

For more information on this file, see
https://docs.djangoproject.com/en/5.2/topics/settings/

For the full list of settings and their values, see
https://docs.djangoproject.com/en/5.2/ref/settings/
"""

from pathlib import Path
from datetime import timedelta
from environs import Env

# Build paths inside the project like this: BASE_DIR / 'subdir'.
BASE_DIR = Path(__file__).resolve().parent.parent

env = Env()
# 读取环境变量，支持多个可能的.env文件位置
env_paths = [
    BASE_DIR.parent / '.env',  # Django项目根目录的.env文件（Docker挂载位置）
    BASE_DIR / '.env',         # backend目录的.env文件
    '.env'                     # 当前工作目录的.env文件
]

for env_path in env_paths:
    try:
        if env_path.exists():
            env.read_env(env_path)
            print(f"Successfully loaded .env from: {env_path}")
            # 打印一些关键环境变量用于调试
            print(f"DEBUG: SECRET_KEY exists: {'SECRET_KEY' in env}")
            print(f"DEBUG: ALIPAY_SERVER_URL exists: {'ALIPAY_SERVER_URL' in env}")
            break
        else:
            print(f"DEBUG: .env file does not exist at: {env_path}")
    except Exception as e:
        print(f"DEBUG: Failed to load .env from {env_path}: {e}")
        continue
else:
    print("Warning: No .env file found, using system environment variables only")

# 打印当前工作目录和BASE_DIR用于调试
print(f"DEBUG: Current working directory: {Path.cwd()}")
print(f"DEBUG: BASE_DIR: {BASE_DIR}")
print(f"DEBUG: Checked env paths: {env_paths}")

# 添加日志配置，用于生产环境调试
LOGGING = {
    'version': 1,
    'disable_existing_loggers': False,
    'formatters': {
        'verbose': {
            'format': '{levelname} {asctime} {module} {process:d} {thread:d} {message}',
            'style': '{',
        },
    },
    'handlers': {
        'console': {
            'class': 'logging.StreamHandler',
            'formatter': 'verbose'
        },
    },
    'root': {
        'handlers': ['console'],
        'level': 'INFO' if not env.bool('DEBUG', default=False) else 'DEBUG',
    },
    'loggers': {
        'django': {
            'handlers': ['console'],
            'level': 'INFO',
            'propagate': False,
        },
        'core.middleware': {
            'handlers': ['console'],
            'level': 'DEBUG',
            'propagate': False,
        },
    },
}


# Quick-start development settings - unsuitable for production
# See https://docs.djangoproject.com/en/5.2/howto/deployment/checklist/

# SECURITY WARNING: keep the secret key used in production secret!
SECRET_KEY = env('SECRET_KEY')

# SECURITY WARNING: don't run with debug turned on in production!
DEBUG = env.bool('DEBUG', default=False)

# 生产环境强制启用静态文件服务（解决Django Admin样式问题）
FORCE_SERVE_STATIC = env.bool('DJANGO_DEV_MODE', default=False)

ALLOWED_HOSTS = ['lms.tyuan21081.top', 'localhost', '127.0.0.1', 'lms-backend', 'backend', 'lms-frontend']

# CSRF配置 - 解决POST请求403/500错误
CSRF_TRUSTED_ORIGINS = [
    'https://lms.tyuan21081.top',
    'http://lms.tyuan21081.top',
    'http://localhost:3000',
    'http://127.0.0.1:3000',
    'http://localhost:8080',
    'http://127.0.0.1:8080',
]

# 确保CSRF cookie在HTTPS下正常工作
CSRF_COOKIE_SECURE = True  # 生产环境使用HTTPS时必须设为True
CSRF_COOKIE_HTTPONLY = False  # 允许JavaScript访问CSRF token
CSRF_COOKIE_SAMESITE = 'Lax'  # 允许跨站请求携带CSRF token

# Session安全配置
SESSION_COOKIE_SECURE = True  # HTTPS环境下session cookie安全传输
SESSION_COOKIE_HTTPONLY = True  # 防止XSS攻击
SESSION_COOKIE_SAMESITE = 'Lax'

# 添加CSRF豁免（对于API请求）
CSRF_EXEMPT_URLS = [
    r'^api/v1/.*$',  # 所有API请求豁免CSRF检查
]

# 或者更简单的方式：禁用CSRF中间件对API的检查
CSRF_USE_SESSIONS = False
CSRF_COOKIE_NAME = 'csrftoken'
CSRF_HEADER_NAME = 'HTTP_X_CSRFTOKEN'

AUTH_USER_MODEL = "userauths.User"
# Application definition

INSTALLED_APPS = [
    "jazzmin",
    "django.contrib.admin",
    "django.contrib.auth",
    "django.contrib.contenttypes",
    "django.contrib.sessions",
    "django.contrib.messages",
    "django.contrib.staticfiles",
    # Custom Apps
    "core",
    "userauths",
    "api",
    # Third Party App
    "rest_framework",
    # "rest_framework_simplejwt.token_blacklist",  # 临时禁用以避免数据库写入问题
    "corsheaders",  # 让跨域请求变为可能，不然react前端请求django后端接口的时候，默认是会被阻止的
    "anymail",  # 邮件服务集成
    "drf_yasg",
    # "djoser",  # 邮件服务，还是使用djoser，anymail不支持qq和谷歌邮箱
]

MIDDLEWARE = [
    "corsheaders.middleware.CorsMiddleware",
    "django.middleware.security.SecurityMiddleware",
    "django.contrib.sessions.middleware.SessionMiddleware",
    "django.middleware.common.CommonMiddleware",
    "core.middleware.CustomCsrfMiddleware",  # 使用自定义CSRF中间件
    "django.contrib.auth.middleware.AuthenticationMiddleware",
    "django.contrib.messages.middleware.MessageMiddleware",
    "django.middleware.clickjacking.XFrameOptionsMiddleware",
]

ROOT_URLCONF = "backend.urls"

TEMPLATES = [
    {
        "BACKEND": "django.template.backends.django.DjangoTemplates",
        "DIRS": [BASE_DIR / "templates"],
        "APP_DIRS": True,
        "OPTIONS": {
            "context_processors": [
                "django.template.context_processors.request",
                "django.contrib.auth.context_processors.auth",
                "django.contrib.messages.context_processors.messages",
            ],
            "builtins": ["core.templatetags.customtags"],
        },
    },
]

WSGI_APPLICATION = "backend.wsgi.application"


# Database
# https://docs.djangoproject.com/en/5.2/ref/settings/#databases

DATABASES = {
    "default": {
        "ENGINE": "django.db.backends.sqlite3",
        "NAME": BASE_DIR / "db.sqlite3",
    }
}


# Password validation
# https://docs.djangoproject.com/en/5.2/ref/settings/#auth-password-validators

AUTH_PASSWORD_VALIDATORS = [
    {
        "NAME": "django.contrib.auth.password_validation.UserAttributeSimilarityValidator",
    },
    {
        "NAME": "django.contrib.auth.password_validation.MinimumLengthValidator",
    },
    {
        "NAME": "django.contrib.auth.password_validation.CommonPasswordValidator",
    },
    {
        "NAME": "django.contrib.auth.password_validation.NumericPasswordValidator",
    },
]


# Internationalization
# https://docs.djangoproject.com/en/5.2/topics/i18n/

LANGUAGE_CODE = "zh-hans"

TIME_ZONE = "Asia/Shanghai"

USE_I18N = True

USE_TZ = True


# Static files (CSS, JavaScript, Images)
# https://docs.djangoproject.com/en/5.2/howto/static-files/

STATIC_URL = "/static/"

# 静态文件收集目录 - 生产环境中Django admin等静态文件的位置
STATIC_ROOT = BASE_DIR / "staticfiles"

# 静态文件目录配置 - 开发阶段的静态文件源目录
STATICFILES_DIRS = [
    BASE_DIR / "static",  # 自定义静态文件目录
]

# 确保静态文件查找器包含所有必要的查找器
STATICFILES_FINDERS = [
    'django.contrib.staticfiles.finders.FileSystemFinder',
    'django.contrib.staticfiles.finders.AppDirectoriesFinder',
]

# 静态文件存储配置
STATICFILES_STORAGE = 'django.contrib.staticfiles.storage.StaticFilesStorage'

MEDIA_URL = "/media/"  # 127.0.0.1/media/avatar.jpg
MEDIA_ROOT = BASE_DIR / "media"


# Default primary key field type
# https://docs.djangoproject.com/en/5.2/ref/settings/#default-auto-field

DEFAULT_AUTO_FIELD = "django.db.models.BigAutoField"

JAZZMIN_SETTINGS = {
    "site_title": "课程管理面板",
    "site_header": "课程管理登录",
    "site_brand": "课程管理",  # 改的是登录之后的左上角的显示的文本，默认显示的是“Django 管理”
    "welcome_sign": "欢迎使用课程管理面板",
    "show_ui_builder": True,
}
JAZZMIN_UI_TWEAKS = {
    "navbar_small_text": False,
    "footer_small_text": False,
    "body_small_text": False,
    "brand_small_text": False,
    "brand_colour": False,
    "accent": "accent-primary",
    "navbar": "navbar-dark",
    "no_navbar_border": False,
    "navbar_fixed": True,
    "layout_boxed": False,
    "footer_fixed": True,
    "sidebar_fixed": True,
    "sidebar": "sidebar-dark-primary",
    "sidebar_nav_small_text": False,
    "sidebar_disable_expand": False,
    "sidebar_nav_child_indent": False,
    "sidebar_nav_compact_style": False,
    "sidebar_nav_legacy_style": False,
    "sidebar_nav_flat_style": False,
    "theme": "solar",
    "dark_mode_theme": None,
    "button_classes": {
        "primary": "btn-primary",
        "secondary": "btn-secondary",
        "info": "btn-info",
        "warning": "btn-warning",
        "danger": "btn-danger",
        "success": "btn-success",
    },
    "actions_sticky_top": False,
}

# Django REST Framework 配置
REST_FRAMEWORK = {
    'DEFAULT_AUTHENTICATION_CLASSES': (
        'rest_framework_simplejwt.authentication.JWTAuthentication',
    ),
    'DEFAULT_PERMISSION_CLASSES': [
        'rest_framework.permissions.IsAuthenticated',
    ],
}

# Swagger配置 - 修复国际化兼容性问题
SWAGGER_SETTINGS = {
    # 安全认证配置 - 定义API文档中的JWT Bearer Token认证方式
    'SECURITY_DEFINITIONS': {
        'Bearer': {
            'type': 'apiKey',  # 认证类型：API密钥
            'name': 'Authorization',  # 请求头名称
            'in': 'header'  # 认证信息位置：请求头中
        }
    },
    'USE_SESSION_AUTH': False,  # 禁用Django会话认证，只使用JWT
    'JSON_EDITOR': True,  # 启用JSON编辑器，方便在文档中编辑请求体
    
    # 支持的HTTP方法 - Swagger UI中可以测试的请求方法
    'SUPPORTED_SUBMIT_METHODS': [
        'get',     # 获取数据
        'post',    # 创建数据
        'put',     # 完整更新数据
        'delete',  # 删除数据
        'patch'    # 部分更新数据
    ],
    
    # 文档界面排序设置
    'OPERATIONS_SORTER': 'alpha',  # API操作按字母顺序排序
    'TAGS_SORTER': 'alpha',       # API标签按字母顺序排序
    
    # 文档展示配置
    'DOC_EXPANSION': 'none',        # 默认不展开任何文档节点
    'DEEP_LINKING': True,           # 启用深度链接，支持直接链接到特定API
    'SHOW_EXTENSIONS': True,        # 显示扩展信息
    'DEFAULT_MODEL_RENDERING': 'model',  # 默认模型渲染方式：显示为模型格式
    
    # 修复Django翻译代理对象问题
    'VALIDATOR_URL': None,  # 禁用在线验证器，避免翻译代理对象错误
    'AUTO_SCHEMA_CLASS': 'drf_yasg.inspectors.SwaggerAutoSchema',  # 使用默认Schema检查器
}

SIMPLE_JWT = {
    "ACCESS_TOKEN_LIFETIME": timedelta(minutes=15),  # 访问令牌有效期（15分钟）
    "REFRESH_TOKEN_LIFETIME": timedelta(days=50),  # 刷新令牌有效期（50天）
    "ROTATE_REFRESH_TOKENS": False,  # 关闭令牌轮换以避免数据库写入
    "BLACKLIST_AFTER_ROTATION": False,  # 关闭黑名单以避免数据库写入
    "UPDATE_LAST_LOGIN": False,  # 是否在用户刷新令牌时更新last_login字段
    "ALGORITHM": "HS256",  # JWT签名算法
    "VERIFYING_KEY": None,  # 公钥（用于非对称加密，HS256无需设置）
    "AUDIENCE": None,  # JWT的aud字段，指定受众
    "ISSUER": None,  # JWT的iss字段，指定签发者
    "JWK_URL": None,  # JWK（JSON Web Key）URL，通常用于公钥自动获取
    "LEEWAY": 0,  # 时间容差（秒），用于校验过期等
    "AUTH_HEADER_TYPES": ("Bearer",),  # 认证头类型，前端请求时需加"Bearer "
    "AUTH_HEADER_NAME": "HTTP_AUTHORIZATION",  # 认证头名称
    "USER_ID_FIELD": "id",  # 用户主键字段名
    "USER_ID_CLAIM": "user_id",  # JWT中存储用户ID的字段名
    "USER_AUTHENTICATION_RULE": "rest_framework_simplejwt.authentication.default_user_authentication_rule",  # 用户认证规则
    "AUTH_TOKEN_CLASSES": (
        "rest_framework_simplejwt.tokens.AccessToken",
    ),  # 允许的Token类型
    "TOKEN_TYPE_CLAIM": "token_type",  # JWT中标识Token类型的字段名
    "TOKEN_USER_CLASS": "rest_framework_simplejwt.models.TokenUser",  # TokenUser类路径
    "JTI_CLAIM": "jti",  # JWT的唯一标识字段名
    "SLIDING_TOKEN_REFRESH_EXP_CLAIM": "refresh_exp",  # Sliding Token刷新过期字段名
    "SLIDING_TOKEN_LIFETIME": timedelta(minutes=5),  # Sliding Token有效期（5分钟）
    "SLIDING_TOKEN_REFRESH_LIFETIME": timedelta(
        days=1
    ),  # Sliding Token刷新有效期（1天）
}

# CORS配置 - 允许前端跨域访问
CORS_ALLOWED_ORIGINS = [
    'https://lms.tyuan21081.top',
    'http://lms.tyuan21081.top',
    'http://localhost:3000',  # 开发环境前端
    'http://127.0.0.1:3000',  # 开发环境前端
    'http://localhost:8080',  # 生产环境前端
    'http://127.0.0.1:8080',  # 生产环境前端
    'http://lms-frontend',    # Docker容器间通信
    'http://lms-frontend:80', # Docker容器间通信
]

# 允许来自同源的请求（解决相对路径API请求的CORS问题）
CORS_ALLOW_ALL_ORIGINS = False
CORS_ALLOWED_ORIGIN_REGEXES = [
    r"^https://lms\.tyuan21081\.top$",
    r"^http://lms\.tyuan21081\.top$",
]

# CORS预检请求设置
CORS_PREFLIGHT_MAX_AGE = 86400  # 24小时缓存预检请求

# 允许的请求头
CORS_ALLOW_HEADERS = [
    "accept",
    "accept-encoding",
    "authorization",
    "content-type",
    "dnt",
    "origin",
    "user-agent",
    "x-csrftoken",
    "x-requested-with",
]

# 允许的请求方法
CORS_ALLOW_METHODS = [
    "DELETE",
    "GET",
    "OPTIONS",
    "PATCH",
    "POST",
    "PUT",
]

# 允许携带cookies
CORS_ALLOW_CREDENTIALS = True

# 配置djoser
# DJOSER = {
#     "USER_ID_FIELD": "username",
#     "LOGIN_FIELD": "username",  # 允许使用用户名登录，❌这个配置已经无效了，因为我已经使用了自定义视图处理登录，而不是使用djoser的登录（djoser登录只支持用户名和邮箱其中的一个，不够灵活。自定义视图可以自由处理，同时支持邮箱和用户名进行登录）
#     "SEND_ACTIVATION_EMAIL": True,  # 发送激活邮箱
#     # "ACTIVATION_URL": "activate/{uid}/{token}",
#     # "PASSWORD_RESET_CONFIRM_URL": "password_reset/{uid}/{token}",
#     # "SEND_CONFIRMATION_EMAIL": True,
#     "PASSWORD_RESET_SHOW_EMAIL_NOT_FOUND": True,  # 设置为True，当数据库中找不到需要重置密码的当前邮箱时，就会报错
#     "PASSWORD_RESET_CONFIRM_RETYPE": True,  # 此配置的作用是：重置密码需要一封重置密码的邮件，这个配置必须设置为True才可以正确发送邮件
#     # "SET_PASSWORD_RETYPE": True,  # 修改密码（set password）时，这个属性必须设置为True
# }

# QQ邮箱配置
DEFAULT_FROM_EMAIL = env(
    "DEFAULT_FROM_EMAIL", default="944412796@qq.com"
)  # 设置默认发件人地址（必须与EMAIL_HOST_USER一致）
SERVER_EMAIL = env("SERVER_EMAIL", default="944412796@qq.com")  # 服务器错误通知发件人
EMAIL_HOST = env("EMAIL_HOST", default="smtp.example.com")
EMAIL_PORT = env("EMAIL_PORT", default=465)
EMAIL_USE_SSL = env.bool("EMAIL_USE_SSL", default=True)  # QQ邮箱必须启用SSL
EMAIL_HOST_USER = env("EMAIL_HOST_USER", default="")
EMAIL_HOST_PASSWORD = env("EMAIL_HOST_PASSWORD", default="")
BREVO_API_KEY = env("BREVO_API_KEY", default="")

# 配置支付宝
ALIPAY_SERVER_URL = env("ALIPAY_SERVER_URL", default="https://openapi-sandbox.dl.alipaydev.com/gateway.do")
# 应用APPID
ALIPAY_APP_ID = env("ALIPAY_APP_ID", default="")
# 应用私钥（非JAVA语言）
ALIPAY_APP_PRIVATE_KEY = env("ALIPAY_APP_PRIVATE_KEY", default="")
# 支付宝公钥
ALIPAY_PUBLIC_KEY = env("ALIPAY_PUBLIC_KEY", default="")
# returnURL
ALIPAY_RETURN_URL = env("ALIPAY_RETURN_URL", default="")
# NotifyURL
ALIPAY_NOTIFY_URL = env("ALIPAY_NOTIFY_URL", default="")
# Seller_id 👉 这个就是沙箱应用信息中的：绑定的商家账号（PID）
ALIPAY_SELLER_Id = env("ALIPAY_SELLER_Id", default="")

# Stripe
STRIPE_SECRET_KEY = env('STRIPE_SECRET_KEY', default="")
STRIPE_PUBLIC_KEY = env('STRIPE_PUBLIC_KEY', default="")

FRONTEND_SITE_URL = env('FRONTEND_SITE_URL', default="http://localhost:3000")
SITE_URL = env('SITE_URL', default="http://localhost:8000")

# Paypal
PAYPAL_CLIENT_ID = env('PAYPAL_CLIENT_ID', default="")
PAYPAL_SECRET_ID = env('PAYPAL_SECRET_ID', default="")
PAYPAL_RECEIVER_EMAIL = env('PAYPAL_RECEIVER_EMAIL', default="")
PAYPAL_TEST = env.bool('PAYPAL_TEST', default=True)
